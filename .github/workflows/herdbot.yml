name: Herdbot Server

on:
  workflow_dispatch:
    inputs:
      instance_number:
        description: 'Instance number (1-3)'
        required: false
        default: '1'
      restart_count:
        description: 'Restart counter'
        required: false
        default: '0'
  repository_dispatch:
    types: [restart-herdbot]

# Cancel any existing runs to avoid conflicts
concurrency:
  group: herdbot-server
  cancel-in-progress: false

env:
  # Workflow timing (in seconds)
  # GitHub has a 6-hour (21600s) limit
  # We run for 5h 50m (21000s) to have buffer
  WORKFLOW_DURATION: 21000
  # Trigger restart 6 minutes before end
  RESTART_THRESHOLD: 20640
  # Time to wait after triggering restart
  OVERLAP_WAIT: 60

jobs:
  run-server:
    runs-on: ubuntu-latest
    timeout-minutes: 350  # 5h 50m

    strategy:
      fail-fast: false
      matrix:
        instance: [1]  # Can expand to [1, 2, 3] for HA

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          pip install -e .
          pip install cloudflared

      - name: Configure environment
        run: |
          echo "HERDBOT_SERVER_ID=herdbot-gh-${{ matrix.instance }}" >> $GITHUB_ENV
          echo "HERDBOT_INSTANCE_NUMBER=${{ matrix.instance }}" >> $GITHUB_ENV
          echo "HERDBOT_API_PORT=8000" >> $GITHUB_ENV
          echo "HERDBOT_LOG_LEVEL=INFO" >> $GITHUB_ENV

      - name: Set up secrets
        env:
          OPENAI_KEY: ${{ secrets.OPENAI_API_KEY }}
          ANTHROPIC_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          if [ -n "$OPENAI_KEY" ]; then
            echo "HERDBOT_OPENAI_API_KEY=$OPENAI_KEY" >> $GITHUB_ENV
          fi
          if [ -n "$ANTHROPIC_KEY" ]; then
            echo "HERDBOT_ANTHROPIC_API_KEY=$ANTHROPIC_KEY" >> $GITHUB_ENV
          fi

      - name: Start Cloudflare Tunnel
        env:
          CF_TOKEN: ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }}
        run: |
          if [ -n "$CF_TOKEN" ]; then
            # Start tunnel in background
            cloudflared tunnel --no-autoupdate run --token "$CF_TOKEN" &
            echo "TUNNEL_PID=$!" >> $GITHUB_ENV
            sleep 5
            echo "Cloudflare tunnel started"
          else
            echo "No Cloudflare tunnel token, skipping"
          fi

      - name: Start Herdbot Server
        id: server
        run: |
          # Record start time
          START_TIME=$(date +%s)
          echo "start_time=$START_TIME" >> $GITHUB_OUTPUT

          # Start server in background
          python -m uvicorn server.api.main:app \
            --host 0.0.0.0 \
            --port 8000 \
            --log-level info &
          SERVER_PID=$!
          echo "server_pid=$SERVER_PID" >> $GITHUB_OUTPUT

          # Wait for server to be ready
          echo "Waiting for server to start..."
          for i in {1..30}; do
            if curl -s http://localhost:8000/health > /dev/null 2>&1; then
              echo "Server is ready!"
              break
            fi
            sleep 10
          done

          # Health check
          curl -s http://localhost:8000/health | jq .

      - name: Monitor and Auto-Restart
        env:
          WORKFLOW_PAT: ${{ secrets.WORKFLOW_PAT }}
        run: |
          START_TIME=${{ steps.server.outputs.start_time }}
          SERVER_PID=${{ steps.server.outputs.server_pid }}
          INSTANCE=${{ matrix.instance }}
          RESTART_TRIGGERED=false

          echo "Server running with PID: $SERVER_PID"
          echo "Monitoring until restart threshold..."

          while true; do
            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - START_TIME))

            # Check if server is still running
            if ! kill -0 $SERVER_PID 2>/dev/null; then
              echo "Server process died, attempting restart..."
              python -m uvicorn server.api.main:app \
                --host 0.0.0.0 \
                --port 8000 \
                --log-level info &
              SERVER_PID=$!
              sleep 10
            fi

            # Check if we should trigger restart
            # Only instance 1 triggers restarts to prevent duplicates
            if [ "$INSTANCE" = "1" ] && \
               [ "$RESTART_TRIGGERED" = "false" ] && \
               [ $ELAPSED -ge $RESTART_THRESHOLD ]; then

              echo "Approaching timeout, triggering restart workflow..."

              # Get current restart count
              CURRENT_RESTART=${{ github.event.inputs.restart_count || github.event.client_payload.restart_count || '0' }}
              NEW_RESTART=$((CURRENT_RESTART + 1))

              # Trigger new workflow via repository_dispatch
              if [ -n "$WORKFLOW_PAT" ]; then
                curl -X POST \
                  -H "Authorization: token $WORKFLOW_PAT" \
                  -H "Accept: application/vnd.github.v3+json" \
                  https://api.github.com/repos/${{ github.repository }}/dispatches \
                  -d "{\"event_type\": \"restart-herdbot\", \"client_payload\": {\"restart_count\": \"$NEW_RESTART\"}}"

                echo "Restart triggered (count: $NEW_RESTART)"
                RESTART_TRIGGERED=true

                # Wait for overlap period
                echo "Waiting ${OVERLAP_WAIT}s for new instance to start..."
                sleep $OVERLAP_WAIT
              else
                echo "WORKFLOW_PAT not set, cannot trigger restart"
              fi
            fi

            # Check if we've exceeded our time limit
            if [ $ELAPSED -ge $WORKFLOW_DURATION ]; then
              echo "Time limit reached, shutting down gracefully..."
              break
            fi

            # Log status every 5 minutes
            if [ $((ELAPSED % 300)) -lt 30 ]; then
              REMAINING=$((WORKFLOW_DURATION - ELAPSED))
              echo "[$(date)] Uptime: ${ELAPSED}s, Remaining: ${REMAINING}s"

              # Quick health check
              curl -s http://localhost:8000/health | jq -c '{status, devices: .devices.online}'
            fi

            sleep 30
          done

      - name: Cleanup
        if: always()
        run: |
          echo "Cleaning up..."

          # Stop server gracefully
          if [ -n "${{ steps.server.outputs.server_pid }}" ]; then
            kill -TERM ${{ steps.server.outputs.server_pid }} 2>/dev/null || true
          fi

          # Stop tunnel
          if [ -n "$TUNNEL_PID" ]; then
            kill -TERM $TUNNEL_PID 2>/dev/null || true
          fi

          echo "Cleanup complete"

      - name: Upload logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: herdbot-logs-${{ matrix.instance }}-${{ github.run_number }}
          path: |
            *.log
          retention-days: 7
